##### 栈(stack)的定义

&ensp;&ensp;栈是限定仅在表尾进行插入或删除操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为**栈顶（top）**，相应的，表头端称为**栈底（bottom）**。不含元素的栈称为**空栈**。

&ensp;&ensp;假设栈 **S=（$a_1$,$a_2$,......,$a_n$）**,则称$a_1$为栈底元素，$a_n$为栈顶元素。栈中的元素按照$a_1$,$a_2$,...$a_n$的顺序进栈，退栈的第一个元素为栈顶元素$a_n$。栈的插入与删除操作是按照后进先出的原则进行，因此栈又称为**后进先出（Last In First Out）**的线性表，简称**LIFO结构**。

##### 栈的表示和实现

&ensp;&ensp;与线性表类似，栈也可以使用顺序存储结构和链式存储结构进行表示。

&ensp;&ensp;顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。

&ensp;&ensp;链栈的操作是链式线性表操作的特例，因此链栈很容易实现，其结构与特性和链式线性表大体相同。

##### 栈的常用场景

- 进制转换

十进制数**N**和其他**d**进制数进行转换时，所遵循的规则如下：

N=(N div d)*d + N mod d(div为整除运算，mod为求余运算)

例如${(1348)}_{10}$ = $({2504})_{8}$，其运算过程如下：

|N|N div 8|N mod 8
|-|-|-|
|1348|168|4|
|168|21|0|
|21|2|5|
|2|0|2|

由以上运算过程与运算规则可知，在每一次进行运算时，将(N mod d)的值推入栈中，并将（N div d）的值重新赋值给N，如此循环，直到（N div d）的值为0，此时栈 中存储的数据，即为进制转换后的数，不过是倒序的，因此，我们需要对栈进行出栈操作，由于后进先出的规则，出栈之后的数就是进制转换后的数了。

- 括号匹配校验

假设表达式中可以使用()，[]两种形式进行组合，每种类型的括号必须成对出现，但是其嵌套的顺序是随意的。为了实现对括号匹配的校验，需要进行如下形式的操作：

表达式=[12*(5+6)-3*(9-7)]

当左括号遇到最近的能与之匹配上的右括号时，则出栈，否则进栈，如果表达式中的所有数据操作完毕后，栈空了，则说明表达式中的括号是能正常匹配的，否则视为括号缺失。

1. 左‘[’进栈，匹配失败；
2. 数字12进栈，匹配失败；
3. 乘号进栈，匹配失败；
4. 左‘（’进栈，匹配失败；
5. 5进栈，匹配失败；
6. 加号进栈，匹配失败；
7. 数字6进栈，匹配失败；
8. 右‘）’进栈，与第4步的左‘（’匹配成功，开始出栈，一直到乘号成为栈顶元素；
9. 减号进栈，匹配失败；
10. 数字3进栈，匹配失败；
11. 乘号进栈，匹配失败；
12. 左‘（’进栈，匹配失败；
13. 数字9进栈，匹配失败；
14. 减号进栈，匹配失败；
15. 数字7进栈，匹配失败；
16. 右‘）’进栈，与第12步的‘（’匹配成功，开始出栈，一直到第二个乘号成为栈顶元素；
17. 右‘]’进栈，与第1步的‘[’匹配成功，开始出栈，一直到最初始的左‘[’出站成功。

此时表达式的所有数据都已操作完毕，栈中也没有任何元素，则说明该表达式的括号能正常匹配。

- 递归函数

函数的递归是程序语言设计中的一个强有力工具。一个直接调用自己或通过一系列的调用语句间接的调用自己的函数，就称为递归函数，比如数学中的阶乘函数,Fibonacci数列，Ackerman函数，有些数据结构本身（如二叉树、广义表等）就具有递归属性，所以它们可以使用递归来进行描述，另有一类问题，其本身没有明显的递归结构，但是使用递归求解比迭代求解更加简单，比如八皇后问题、汉诺塔问题等。

递归的调用必须有一个明确的出口限定，即递归不能无限制进行下去。因为栈的大小是有限度的，当递归无止尽的进行时，栈的空间会在很短时间内被占用完，当栈满时，再对栈进行入栈操作，就会触发栈溢出异常，很显然这并不是我们希望看到的结果。因此，在使用递归函数的同时，必须要合理设计递归的逻辑出口，否则，递归将变成一个定时炸弹而不是有效的工具。（*关于递归函数的更多细节，后续会补充相关的专题内容进行详细分析*）。