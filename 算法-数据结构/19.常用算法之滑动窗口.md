[TOC]

#### 什么是滑动窗口

熟悉TCP/IP协议的小伙伴，应该都知道，TCP在进行流量控制的时候，使用了一种叫滑动窗口的协议。

滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。其他细节，详见[滑动窗口协议][1]。

从TCP的滑动窗口协议引申到算法中，就是滑动窗口算法。主要用来解决对数组不特定序列进行额外的逻辑操作与控制，而滑动窗口的定义，就和其名称一样，先有窗口，然后是不停的滑动，最后产生预期的结果。

#### 滑动窗口算法的思想

滑动窗口是一种解决问题的思路，而不是某种特定的数据结构。可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，从而减少重复计算，降低时间复杂度。往往类似于“ 请找到满足 xx 的最 x 的区间（子串、子数组）的 xx ”这类问题都可以使用该方法进行解决。

算法的核心思想在于，先对给定的序列$$S$$进行窗口设置，包括窗口的大小，起始位置等，然后基本窗口的大小查找满足条件的子序列，并返回结果。对于窗口的大小，既可以是动态的，也可以是定长的。如果是动态大小的滑动窗口，那么算法在执行的时候，会不停的增大窗口大小，直到和序列$$S$$长度一样为止。

#### 算法案例

##### 案例一

```Shell
给定一个数组array，输出数组array中连续元素的和sums，要求这个和sums是所有和中最大的一个。例如输入：array=[-3, 4, -1, 6, -2, -6, -5]，输出sums=9，即子序列为[4, -1, 6].
```

这就是一个典型的滑动窗口求和的案例，要求在一个数组中找到和最大的连续子数组。具体实现见如下代码：

```Python
def sliding_window(array):
    """滑动窗口算法

    Args:
        array(list): 给定的序列

    Returns:
        result(any): 结果
    """
    result = None
    length = len(array)

    # 由于窗口大小是动态的，因此第一层for循环为动态设置滑动窗口大小，从1开始，到array长度为止
    for i in range(1, length+1):
        # 第二层for循环决定滑动窗口滑动的位置，允许滑动的起始位置为array长度减去窗口大小加1
        for j in range(length - i + 1):
            # 使用sum，对滑动窗口选取的子序列进行求和，并和标记位进行比较，总是将最大的结果赋值给标记位
            sums = sum(array[j: j+i])
            if result is None:
                print(f'第一次对标记位赋值，求和子序列为{array[j: j+i]}，和为{sums}')
                result = sums
            else:
                if sums > result:
                    print(f'对标记位赋值，求和子序列为{array[j: j + i]}，和为{sums}，上一次最大和为{result}')
                    result = sums
    return result


if __name__ == '__main__':
    array = [-3, 4, -1, 6, -2, -6, -5]
    print(f'数组{array}的子序列中，和最大的值为：{sliding_window(array)}')
```

对应的输出结果为

```Python
第一次对标记位赋值，求和子序列为[-3]，和为-3
对标记位赋值，求和子序列为[4]，和为4，上一次最大和为-3
对标记位赋值，求和子序列为[6]，和为6，上一次最大和为4
对标记位赋值，求和子序列为[4, -1, 6]，和为9，上一次最大和为6
数组[-3, 4, -1, 6, -2, -6, -5]的子序列中，和最大的值为：9
```

##### 案例二

```Shell
给定一个字符串s，获得其中最长的连续不重复子串。例如：s='abcadedcfef'，输出最长子串为：bcade.
```

这也是一个滑动窗口算法的典型应用场景。具体代码如下：

```Python
def sliding_window(s):
    """滑动窗口算法

    Args:
        s(str): 给定的字符串

    Returns:
        result(any): 结果
    """
    sub_string = None
    length = len(s)

    for i in range(1, length+1):
        for j in range(length-i+1):
            tmp = s[j: j+i]
            if len(list(set(tmp))) == len(tmp):  # 当且仅当子序列中无重复字符串时，才开始进行子串的赋值
                if sub_string is None:
                    print(f'第一次对子串赋值，不重复子串为{tmp}，长度为{len(tmp)}')
                    sub_string = tmp
                else:
                    if len(sub_string) < len(tmp):
                        print(f'对子串赋值，不重复子串为{tmp}，长度为{len(tmp)}，上一次最长子串为{sub_string}，其长度为{len(sub_string)}')
                        sub_string = tmp
    return sub_string


if __name__ == '__main__':
    s = 'abcadedcfef'
    print(f'字符串:{s} 的最长不重复子串为：{sliding_window(s)}')
```

输出结果如下：

```Shell
第一次对子串赋值，不重复子串为a，长度为1
对子串赋值，不重复子串为ab，长度为2，上一次最长子串为a，其长度为1
对子串赋值，不重复子串为abc，长度为3，上一次最长子串为ab，其长度为2
对子串赋值，不重复子串为bcad，长度为4，上一次最长子串为abc，其长度为3
对子串赋值，不重复子串为bcade，长度为5，上一次最长子串为bcad，其长度为4
字符串:abcadedcfef 的最长不重复子串为：bcade
```

#### 结语

从上述两个算法案例中，我们不难发现，滑动窗口算法的关键点在于，**如何设置滑动窗口的大小**，以及**确定滑动窗口滑动的起始位置**，只要确定了这两个关键点，那么问题本身就很好解决了。

[1]: https://baike.baidu.com/item/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/8351795?fr=aladdin "滑动窗口协议"