#### 什么是有限状态机

有限状态机(FSM: Finite State Machine)是一种用来进行对象行为建模的工具，简称状态机。其主要作用是描述对象在它的生命周期内所经历的状态序列，
以及如何响应来自外界的各种事件，是现实事物运行规则抽象而成的一个数学模型。在计算机科学中，有限状态机被广泛应用与建模应用行为、硬件电路设计图、
软件工程、编译器、网络协议、计算和语言的研究等。

#### 有限状态机的要素

状态机可以归纳为以下四个要素：

1. 现态(State)：对象的当前状态
2. 条件(Event)：又称事件，当条件被满足时，将会触发一个动作或者执行一次状态的转移
3. 动作(Action)：事件发生以后的执行动作。动作不是必需的，满足条件后也可以直接执行状态的转移
4. 次态(Transition)：条件满足后或者执行动作后转移的新状态。次态是一个相对与现态的状态，当状态转移完成后，次态就会变成新的现态

#### 一个简单的示例：门的有限状态机

对门这个对象进行数据建模，我们可以将其状态机定义为如下格式：

现态 | 条件 | 动作 | 次态 |
--- | --- | --- | --- |
开启  | 门处于开启状态 | 拉门 | 关闭 |
关闭  | 门处于关闭状态 | 推门 | 开启 |
半开启  | 门处于半开启状态 | 推门 | 开启 |
半开启  | 门处于半开启状态 | 拉门 | 关闭 |

门这个对象一共有三个状态：开启、关闭和半开启，同时开门的时候需要进行推门的动作，关门的时候需要进行拉门的动作，在执行完对应的动作后，门的状态就会产生变化。

上述表格完整的描述了门这个对象的状态机，我们可以通过这个状态机，实现门的全自动状态转移。

#### 一个复杂的示例：考勤的有限状态机

假如考勤的范围是周一至周五的朝九晚六，同时法定节假日统一算出勤，则一个员工的考勤有以下状态：正常、上午正常、迟到、早退、旷工、请假、未打卡。

我们可以定义如下状态机进行考勤的数据建模：

现态 | 条件 | 动作 | 次态 |
--- | --- | --- | --- |
未打卡 | 第一次打卡为上午九点前 | 刷卡机刷卡 | 上午正常 |
未打卡 | 第一次打卡为上午九点后 | 刷卡机刷卡 | 迟到 |
未打卡 | 全天无打卡记录 | 考勤结算 | 旷工 |
未打卡 | 全天无记录但是为法定节假日 | 考勤结算 | 正常 |
未打卡 | 全天无记录但是有请假记录| 考勤结算 | 请假 |
上午正常| 最后一次打卡为下午六点后 | 考勤结算 | 正常 |
上午正常 | 最后一次打卡为下午六点前 | 考勤结算 | 早退 |
上午正常 | 最后一次打卡为下午六点前且有请假记录 | 考勤结算 | 请假 |
迟到 | 最后一次打卡为下午六点后且有请假记录 | 考勤结算 | 请假 |
迟到 | 最后一次打卡为下午六点前 | 考勤结算 | 旷工 |

通过上述表格对考勤状态的描述，我们可以轻易分解出考勤的一整个流程，无论是对产品设计还是程序设计，状态机都能发挥出相当出色的作用，
同时还能帮助我们解析问题的本质，更进一步的设计出更优秀的产品。

#### 更复杂的状态机

上述关于门的状态机，是一个简单的一级一维状态机，相对应的，还有多级状态机，多维状态机。

##### 多级状态机

在分层的多级状态机里，一个“父状态”下可以划分多个“子状态”，这些子状态共同拥有上级父状态的某些共性，同时又各自拥有自己的一些独有特性。

比如上述考勤的状态机里，我们就可以将其设计为多级状态机，其中打卡和未打卡是两个父状态，在这两个父状态下，又可以将迟到、早退、请假、旷工分别
归类于某一个父状态下。

##### 多维状态机

如果从不同的角度对系统进行状态机的设计，就可以得到一个多维状态机。在多维状态机中，状态的某些特性是交叉的，它们可以同时存在且相互联系，从而构成多维状态机。

比如一个遥控器的状态机，从按键使用的角度上，可以设计一套状态机，从屏幕显示上又可以设计一套状态机，但是不管从按键还是屏幕，它们互相之间又是存在交叉和联系的，
因此就可以将其设计为一个多维状态机。

#### 状态机中的陷阱

##### 伪态

如果在设计状态时，没有很好的区分动作(Action)和状态(State),那么就会出现误将某种动作当成状态，这就是伪态。

为了避免伪态的出现，在划分对象的状态时，需要注意，动作是不稳定的，满足条件后动作只要一触发就会立刻结束，而状态是稳定的，如果没有外部条件的触发，
一个状态就会一直持续下去。

##### 漏态

如果在划分状态时，漏掉了某些状态，就会出现漏态的情况。

状态机的另一个名称也叫全自动有限状态机，突出的关键词就是自动和有限，当一个对象的状态机被完全确定的时候，这个状态机的所有状态就会在满足条件和动作触发的时候，
自动完成状态的转移。如果出现漏态，那么由于状态的缺失，在某些条件和动作下，状态转移就会失败。

#### Python实现状态机

我们以门的状态机为例，通过Python实现状态机的描述。

```python
class DoorStateMachine:
    """关于门的有限状态机"""
    DOOR_STATE_MACHINE = {
        "open": {
            "pull": "close"
        },
        "close": {
            "push": "open"
        },
        "half-open": {
            "pull": "close",
            "push": "open"
        }
    }

    def __init__(self):
        self.state = "close"

    def state_transaction(self, action):
        try:
            self.state = self.DOOR_STATE_MACHINE[self.state][action]
        except KeyError:
            print(f"状态 {self.state} 无法通过动作 {action} 转移至新状态")
        return
```

当门处于关闭状态时，给门发送push动作，会将门的关闭状态转移为开启状态

```python
dsm = DoorStateMachine()
print(f"当前门处于 {dsm.state} 状态")
dsm.state_transaction(action="push")
print(f"给门发送push动作后，门处于 {dsm.state} 状态")

# Output
当前门处于 close 状态
给门发送push动作后，门处于 open 状态
```

如果在门处于关闭状态的时候，给门发送pull动作，就会违背状态机的状态转移定义，导致状态转移失败

```python
dsm = DoorStateMachine()
print(f"当前门处于 {dsm.state} 状态")
dsm.state_transaction(action="pull")

# Output
当前门处于 close 状态
状态 close 无法通过动作 pull 转移至新状态
```

以上就是python对状态机的简易实现与描述。

