#### Migration潜在的问题

&ensp;&ensp;当项目由多个人进行开发维护时，每个开发者在修改完model后，都会有一份自己本地的migrations文件，这些migrations文件有着比较明确的依赖关系，当项目某一阶段完成时，在进行集成测试的过程中，可能就会出现migrations文件版本不一致的问题。此时再想通过migrations操作进行数据库的关系映射，就会报错。

&ensp;&ensp;从migrations设计的的角度来看，所有的migrations文件应该是一个线性的进程，所以维护线性线程最简洁的方式，就是单线操作，而多人开发时，就不是简单的线性操作了，会有很多条线最终需要在某一个节点汇聚到一起，这种节点就是项目开发中的某一个周期节点，比如需求的完成。

#### 解决方案

&ensp;&ensp;从这个角度去理解，要想保证migrations方式在项目的整个生命周期中一直可用并且随时可用，就需要保存好单线的所有migrations文件，在每一次节点的汇聚时，统一使用相同的migrations文件来构建数据库映射关系。此为其中一种比较偏向于自定义的解决方案，我之前就将项目所有阶段生成的migrations文件统一读取到backend的数据库中，在每次项目部署的时候，只要数据库不换，都需要先行拉取历史的migrations文件，然后再把本次的数据库迁移通过正常的makemigrations和migrate完成，完成之后再将本次生成的migrations文件存会数据库中。如此一来，不管如何开发，都能保证有一条线性的迁移队列，能将整个迁移流程完整保存。

&ensp;&ensp;如果不想使用这种自定义方案，其实django自身也提供了一种方式，具体操作如下：

1.创建django项目并新增app：
```linux
djtest
    djtest
    	__init__.py
    	asgi.py
    	settings.py
    	urls.py
    	wsgi.py
    app
	migrations
	    __init__.py
	__init__.py
	admin.py
	apps.py
	models.py
	tests.py
	views.py
    manage.py    
```

2.在app.models创建测试用的模型：
```Python
from django.db import models


class TestModel(models.Model):
    name = models.CharField(max_length=100)

```

3.修改settings中的数据库配置(如果用sqlite也行)

4.生成迁移文件
```Python
python manage.py makemigrations

Migrations for 'app':
  app\migrations\0001_initial.py
    - Create model TestModel
```

5.查看生成的迁移文件 **migrations/0001_initial.py**
```Python
# -*- coding: utf-8 -*-
# Generated by Django 1.11.12 on 2020-10-22 10:45
from __future__ import unicode_literals

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='TestModel',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
            ],
        ),
    ]

```

6.执行数据库迁移（第一次迁移会有django自身默认的数据库迁移）
```Python
python manage.py migrate

Operations to perform:
  Apply all migrations: admin, app, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying admin.0004_auto_20200927_1900... OK
  Applying app.0001_initial... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying auth.0013_auto_20200927_1900... OK
  Applying sessions.0001_initial... OK
```

7.使用工具连接数据库，查看生成的表，能看见一堆django的默认表，以及刚才创建的TestModel生成的test_model表，关于django的迁移操作，需要关注django_migrations和django_content_type这两张表中的内容。前者保存了django迁移过程中已经执行过的迁移文件信息，后者保存着app中的model的映射关系。

8.这个时候假设是我们项目开发中的第一个节点(假设为一期目标)，此时的数据库已经在正常运行，接下来要面临二期开发及迭代。

9.二期开发时，新增了一张表，并将test_model表新增一个age字段：
```Python
from django.db import models


class TestModel(models.Model):
    name = models.CharField(max_length=100)
    age = models.SmallIntegerField(default=0)


class TestModelB(models.Model):
    name = models.CharField(max_length=100)
```

10.开发完成后，项目需要去客户现场部署升级。在升级的过程中，假设我们将一期目标生成迁移文件弄丢了，那么就会出现我们开篇提到的问题(模拟场景，删除本地的migrations/0001_initial.py文件并清空django_migrations表)

11.为了让我们新开发的模型顺利通过migrate进入数据库中，需要在项目部署之前，先通过一期的项目代码生成历史迁移文件：
```Python
python manage.py makemigrations

Migrations for 'app':
  app\migrations\0001_initial.py
    - Create model TestModel
```

12.将一期的迁移文件写进迁移记录django_migrations表中，但是不实际执行sql操作
```Python
python manage.py migrate --fake
python manage.py migrate --fake-initial  # 这个是对所有的app进行初始化

Operations to perform:
  Apply all migrations: admin, app, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... FAKED
  Applying auth.0001_initial... FAKED
  Applying admin.0001_initial... FAKED
  Applying admin.0002_logentry_remove_auto_add... FAKED
  Applying admin.0003_logentry_add_action_flag_choices... FAKED
  Applying admin.0004_auto_20200927_1900... FAKED
  Applying app.0001_initial... FAKED
  Applying contenttypes.0002_remove_content_type_name... FAKED
  Applying auth.0002_alter_permission_name_max_length... FAKED
  Applying auth.0003_alter_user_email_max_length... FAKED
  Applying auth.0004_alter_user_username_opts... FAKED
  Applying auth.0005_alter_user_last_login_null... FAKED
  Applying auth.0006_require_contenttypes_0002... FAKED
  Applying auth.0007_alter_validators_add_error_messages... FAKED
  Applying auth.0008_alter_user_username_max_length... FAKED
  Applying auth.0009_alter_user_last_name_max_length... FAKED
  Applying auth.0010_alter_group_name_max_length... FAKED
  Applying auth.0011_update_proxy_permissions... FAKED
  Applying auth.0012_alter_user_first_name_max_length... FAKED
  Applying auth.0013_auto_20200927_1900... FAKED
  Applying sessions.0001_initial... FAKED
```

13.做完以上操作后，我们就拿到了一期的历史迁移记录，将其备份，并放入二期代码中的app/migrations文件夹中，这样我们就在二期的项目代码中拥有了一期的迁移历史节点，此时就可以了按照正常流程进行迁移操作了。

14.执行迁移操作：
```Python
python manage.py makemigrations

Migrations for 'app':
  app\migrations\0002_auto_20201022_1916.py
    - Create model TestModelB
    - Add field age to testmodel
 
python manage.py migrate

Operations to perform:
  Apply all migrations: admin, app, auth, contenttypes, sessions
Running migrations:
  Applying app.0002_auto_20201022_1916... OK
```

15.连接数据库，可以看到迁移已经正常完成，新字段和新表都已经添加到数据库中。