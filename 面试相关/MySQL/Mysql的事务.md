##### 定义
一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务

##### 四大特征
- **原子性(A)**：事务是最小单位，不可再分
- **一致性(C)**：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败
- **隔离性(I)**：事务A和事务B之间具有隔离性
- **持久性(D)**：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)

##### 常见问题
- 更新丢失（Lost Update）

原因：当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。类比github提交冲突。

- 脏读（Dirty Reads）

原因：事务A读取了事务B已经修改但尚未提交的数据。若事务B回滚数据，事务A的数据存在不一致性的问题。

- 不可重复读（Non-Repeatable Reads）

原因：事务A第一次读取最初数据，第二次读取事务B已经提交的修改或删除数据。导致两次读取数据不一致。不符合事务的隔离性。

- 幻读（Phantom Reads）

原因：事务A根据相同条件第二次查询到事务B提交的新增数据，两次数据结果集不一致。不符合事务的隔离性

##### 事务的隔离级别

- 读未提交（最低的隔离级别，读操作可以读未提交事务的sql语句对数据库的操作。这种隔离机制无法保证数据的原子性，读了没有提交成功的数据便是脏读。读未提交本身就是不能保证原子性，所以一般不会用。）
- 读已提交（数据读取必须要在处理该数据的事务被回滚或者提交完成后才进行，这样可以保证同一数据的修改和读取不同时进行，从而保证数据的一致性。当然，它解决了脏读的问题，但是却没有解决另外一个问题，即不可重复读的带来的问题）
- 可重复读（解决不可重复读问题。其实就是在不可重复读的基础上，当数据在前后两个读取操作时都相应地加上对应数据的锁，使得两次读取期间不能有其他线程对数据进行操作，保证读的结果是重复的，也即是保证读数据的一致性），**默认级别**
- 串读（最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，它锁定了整个表，是的所有线程的操作都是串行进行的，可彻底杜绝幻读的情况。当然，锁定整个表，性能会下降得非常厉害，所以实际中应该谨慎的选择。）

事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。