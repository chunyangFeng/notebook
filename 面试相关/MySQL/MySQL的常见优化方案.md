#### 具体的优化方案
- SQL 语句中 IN 包含的值不应过多，MySQL 对于 IN 做了相应的优化，即将 IN 中的常量全部存储在一个数组里面，而且这个数组是排好序的，但是如果数值较多，产生的消耗也是比较大的。
- SELECT 语句务必指明字段名称，SELECT * 增加很多不必要的消耗，也增加了使用覆盖索引的可能性
- 当只需要一条数据的时候，使用 limit 1（这是为了使 EXPLAIN 中 type 列达到 const 类型 ）
- 如果排序字段没有用到索引，就尽量少排序
- 如果限制条件中其他字段没有索引，尽量少用 or，or 两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用union all或者是union(必要的时候)的方式来代替“or”会得到更好的效果
- 尽量用 union all 代替 union，union 和 union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU 运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据
- 不使用ORDER BY RAND()
- 区分in和exists， not in和not exists
- 使用合理的分页方式以提高分页的效率
- 分段查询
- 避免在 where 子句中对字段进行null值判断，对于null的判断会导致引擎放弃使用索引而进行全表扫描。
- 不建议使用 % 前缀模糊查询，这种查询会导致索引失效而进行全表扫描
- 避免在where子句中对字段进行表达式操作
- 避免隐式类型转换
- 对于联合索引来说，要遵守最左前缀法则
- 必要时可以使用 force index 来强制查询走某个索引
- 注意范围查询语句，对于联合索引来说，如果存在范围查询，比如 between,>,< 等条件时，会造成后面的索引字段失效。
- 关于 JOIN 优化

#### 总体方案
- 设计良好的数据库结构
- 允许部分数据冗余，尽量避免join查询，提高效率
- 选择合适的表字段和存储引擎
- 添加合适的索引
- 主从读写分离
- 分表，减少表中的数据量提高查询速度